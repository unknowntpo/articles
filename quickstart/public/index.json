[{"categories":null,"content":"Experiment: To demonstrate the improvement of our code, I design a simple benchmark, There are three ways we can get data from database. Use []Author to hold the data (Structure Binding) Use [][]string to hold the data (Unify Container without sync.Pool) Use [][]string to hold the data, and use sync.Pool to reuse [][]string (Unify Container with sync.Pool) For row number between 1000 and 8000 to demonstrate the benefit of sync.Pool, we use runtime.NumCPU() worker to perform runtime.NumCPU()*4 jobs, every job gets all rows from the author table $ make BENCHTIME=1s go test -benchmem -benchtime=1s \\ -bench=. \\ | tee data/result_all.txt goos: darwin goarch: arm64 pkg: github.com/unknowntpo/playground-2022/go/xorm/unifyContainer BenchmarkContainer/StructureBinding-1000-8 13 78949647 ns/op 91926655 B/op 3146081 allocs/op BenchmarkContainer/UnifyContainerWithPool-1000-8 31 39028380 ns/op 31799634 B/op 1882362 allocs/op BenchmarkContainer/UnifyContainerNoPool-1000-8 22 48651809 ns/op 48547759 B/op 2407600 allocs/op BenchmarkContainer/StructureBinding-2000-8 8 137213729 ns/op 189730109 B/op 6284178 allocs/op BenchmarkContainer/UnifyContainerWithPool-2000-8 15 72343683 ns/op 63592857 B/op 3759864 allocs/op BenchmarkContainer/UnifyContainerNoPool-2000-8 12 87559920 ns/op 97780912 B/op 4807668 allocs/op BenchmarkContainer/StructureBinding-3000-8 6 199308167 ns/op 281507561 B/op 9422225 allocs/op BenchmarkContainer/UnifyContainerWithPool-3000-8 10 105695333 ns/op 97377107 B/op 5654077 allocs/op BenchmarkContainer/UnifyContainerNoPool-3000-8 8 128159927 ns/op 146226483 B/op 7207695 allocs/op BenchmarkContainer/StructureBinding-4000-8 4 256713490 ns/op 379839898 B/op12560279 allocs/op BenchmarkContainer/UnifyContainerWithPool-4000-8 8 140550521 ns/op 129773817 B/op 7537186 allocs/op BenchmarkContainer/UnifyContainerNoPool-4000-8 7 165150417 ns/op 195457696 B/op 9607724 allocs/op BenchmarkContainer/StructureBinding-5000-8 4 323341906 ns/op 486299350 B/op15698332 allocs/op BenchmarkContainer/UnifyContainerWithPool-5000-8 7 162782482 ns/op 163561488 B/op 9417513 allocs/op BenchmarkContainer/UnifyContainerNoPool-5000-8 5 200822450 ns/op 245477224 B/op12007762 allocs/op BenchmarkContainer/StructureBinding-6000-8 3 404629153 ns/op 594317120 B/op18836278 allocs/op BenchmarkContainer/UnifyContainerWithPool-6000-8 6 195379785 ns/op 195452422 B/op11307507 allocs/op BenchmarkContainer/UnifyContainerNoPool-6000-8 4 258140198 ns/op 296804806 B/op14407787 allocs/op BenchmarkContainer/StructureBinding-7000-8 3 512568570 ns/op 720955394 B/op21974306 allocs/op BenchmarkContainer/UnifyContainerWithPool-7000-8 4 251422083 ns/op 224965602 B/op13170581 allocs/op BenchmarkContainer/UnifyContainerNoPool-7000-8 4 288070792 ns/op 349445756 B/op16807820 allocs/op BenchmarkContainer/StructureBinding-8000-8 2 531542583 ns/op 792064800 B/op25112484 allocs/op BenchmarkContainer/UnifyContainerWithPool-8000-8 4 271685614 ns/op 260817526 B/op15089126 allocs/op BenchmarkContainer/UnifyContainerNoPool-8000-8 4 338913490 ns/op 395270596 B/op19207827 allocs/op PASS ok github.com/unknowntpo/playground-2022/go/xorm/unifyContainer 46.676s The result shows that the number of allocation per operation is quite different, The Structure Binding Method needs the largest number of allocations, and the speed is way slower that other two methods. When row number goes high, performance get worse very quickly. The Method of using [][]string with sync.Pool on the other hand, needs smallest number of memory allocation, and compare to the one without sync.Pool, and because memory allocation takes significant amount of time, it’s still faster. Here’s the plot: I put my code at the repo, please go check it out! ","date":"2023-02-13","objectID":"/syncpool/:0:0","tags":["sync.Pool","performance","Go"],"title":"Use `sync.Pool` to reduce memory consumption","uri":"/syncpool/"},{"categories":null,"content":"Identifying the root cause SELECT dbKey.*, finalDBData.* FROM dbKey, ( SELECT *, rank() OVER (PARTITION BY key_id ORDER BY TIMESTAMP DESC) AS rank FROM dbData where \"timestamp\" \u003c= 101) finalDBData where rank =1 and finalDBData.key_id = dbKey.id; Because it has to scan the whole dbData table, partition it by key_id, and rank the timestamp, planner tend to range over every row in data table to get `rank=1` data, then join it with key table, finally returns it back to client. so it’s so slow, we current have about 30000 keys in key table, each project has about 2000 keys, and almost 100 milion data rows in data table. It usually takes at least 60 second to get the particular version of data. ","date":"2023-02-12","objectID":"/idx-only-scan/:1:0","tags":null,"title":"Optimize a SELECT query up to 60x faster","uri":"/idx-only-scan/"},{"categories":null,"content":"Improvement: Index-Only Scan But this query still can be better, There’s a new feature introduced in PostgreSQL 9.2, which allow us to get data from index itself, without touching the actual table data. The documentation stats that There are two fundamental restrictions on when this method can be used: The index type must support index-only scans. B-tree indexes always do. GiST and SP-GiST indexes support index-only scans for some operator classes but not others. Other index types have no support. The underlying requirement is that the index must physically store, or else be able to reconstruct, the original data value for each index entry. As a counterexample, GIN indexes cannot support index-only scans because each index entry typically holds only part of the original data value. The query must reference only columns stored in the index. For example, given an index on columns x and y of a table that also has a column z, these queries could use index-only scans: The first one is staicfied because we are using B-tree index. The second one can be satisfied by modifying our SQL query, We can build the mapping between key_id and the rank=1 timestamp first, WITH map AS ( SELECT key_id, timestamp FROM ( SELECT key_id, timestamp, rank() OVER (PARTITION BY key_id ORDER BY TIMESTAMP DESC) AS rank FROM dbData where \"timestamp\" \u003c= 10000 and key_id \u003c 100 ) sub WHERE rank = 1) SELECT * FROM map; Result will be like: key_id | timestamp --------+----------- 1 | 10000 2 | 300 3 | 6000 4 | 90303 and then, get actual data from dbData with specific key_id and timestamp pair. WITH map AS ( SELECT key_id, timestamp FROM ( SELECT key_id, timestamp, rank() OVER (PARTITION BY key_id ORDER BY TIMESTAMP DESC) AS rank FROM dbData where \"timestamp\" \u003c= 10000 and key_id \u003c 100 ) sub WHERE rank = 1) SELECT dbKey.*, dbData.* FROM dbKey INNER JOIN map m ON m.key_id = dbKey.id INNER JOIN dbData ON dbData.key_id = m.key_id AND m.timestamp = dbData.timestamp; The reason we build the map first is that the select list in map are all stored in the index, which satisfied requirement 2 in the documentation, and later when we query dbData , we can still have Index Scan. Here’s the example query plan Reference: PostgreSQL Wiki ","date":"2023-02-12","objectID":"/idx-only-scan/:2:0","tags":null,"title":"Optimize a SELECT query up to 60x faster","uri":"/idx-only-scan/"},{"categories":null,"content":"This is my first glance of ChatGPT, and I ask her to generate a peice of code in Haskell, which can map a function to a list. The result she generated is totally correct, and can be run in playground. addOneToEach :: [Int] -\u003e [Int] addOneToEach xs = map (+1) xs myMap :: (a -\u003e b) -\u003e [a] -\u003e [b] myMap _ [] = [] myMap f (x:xs) = f x : myMap f xs main = do let myList = [1, 2, 3, 4] let doubledList = myMap (*2) myList print doubledList -- Output: [2,4,6,8] Here’s the link to our chat: https://sharegpt.com/c/yedzb1N ","date":"2023-01-21","objectID":"/chatgpt-first-glance/:0:0","tags":null,"title":"ChatGPT First Glance","uri":"/chatgpt-first-glance/"},{"categories":null,"content":"Hello, This is my first time trying Hugo! Inline Formula: SELECT 'hello-world' FROM me Block Formula: ","date":"2023-01-08","objectID":"/my-first-post/:0:0","tags":null,"title":"My First Post","uri":"/my-first-post/"},{"categories":null,"content":"I am unknowntpo, a Backend Software Engineer. ","date":"2023-01-08","objectID":"/about/:0:0","tags":null,"title":"About me","uri":"/about/"}]