<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Known, Unknown, Unknownable</title>
        <link>/</link>
        <description>My secret universe</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>e850506@gmail.com (unknowntpo)</managingEditor>
            <webMaster>e850506@gmail.com (unknowntpo)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 12 Feb 2023 14:23:03 &#43;0800</lastBuildDate>
            <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>Part3: Use Index-Only Scan to make our query even faster</title>
    <link>/idx-only-scan/</link>
    <pubDate>Sun, 12 Feb 2023 14:23:03 &#43;0800</pubDate>
    <author>unknowntpo</author>
    <guid>/idx-only-scan/</guid>
    <description><![CDATA[But this query still can be better,
There&rsquo;s a new feature introduced in PostgreSQL 9.2, which allow us to get data from index itself, without touching the actual table data.
📍 TODO: consider the visibility map
We can build the mapping between key_id and the rank=1 timestamp first,
1 2 3 4 5 6 7 8 9 10 11 12 13 14 WITH map AS ( SELECT key_id, timestamp FROM ( SELECT key_id, timestamp, rank() OVER (PARTITION BY key_id ORDER BY TIMESTAMP DESC) AS rank FROM dbData where &#34;timestamp&#34; &lt;= 10000 and key_id &lt; 100 ) sub WHERE rank = 1) SELECT * FROM map; Result will be like:]]></description>
</item>
<item>
    <title>ChatGPT First Glance</title>
    <link>/chatgpt-first-glance/</link>
    <pubDate>Sat, 21 Jan 2023 12:00:58 &#43;0800</pubDate>
    <author>unknowntpo</author>
    <guid>/chatgpt-first-glance/</guid>
    <description><![CDATA[This is my first glance of ChatGPT, and I ask her to generate a peice of code in Haskell, which can map a function to a list.
The result she generated is totally correct, and can be run in playground.
1 2 3 4 5 6 7 8 9 10 11 12 addOneToEach :: [Int] -&gt; [Int] addOneToEach xs = map (+1) xs myMap :: (a -&gt; b) -&gt; [a] -&gt; [b] myMap _ [] = [] myMap f (x:xs) = f x : myMap f xs main = do let myList = [1, 2, 3, 4] let doubledList = myMap (*2) myList print doubledList -- Output: [2,4,6,8] Here&rsquo;s the link to our chat: https://sharegpt.]]></description>
</item>
<item>
    <title>My First Post</title>
    <link>/my-first-post/</link>
    <pubDate>Sun, 08 Jan 2023 19:38:19 &#43;0800</pubDate>
    <author>unknowntpo</author>
    <guid>/my-first-post/</guid>
    <description><![CDATA[Hello, This is my first time trying Hugo! Inline Formula: 1 SELECT &#39;hello-world&#39; FROM me Block Formula:]]></description>
</item>
<item>
    <title>About me</title>
    <link>/about/</link>
    <pubDate>Sun, 08 Jan 2023 15:38:19 &#43;0800</pubDate>
    <author>unknowntpo</author>
    <guid>/about/</guid>
    <description><![CDATA[I am unknowntpo, a Backend Software Engineer. ]]></description>
</item>
</channel>
</rss>
