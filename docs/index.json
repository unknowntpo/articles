[{"categories":null,"content":"Identifying the root cause SELECT dbKey.*, finalDBData.* FROM dbKey, ( SELECT *, rank() OVER (PARTITION BY key_id ORDER BY TIMESTAMP DESC) AS rank FROM dbData where \"timestamp\" \u003c= 101) finalDBData where rank =1 and finalDBData.key_id = dbKey.id; Because it has to scan the whole dbData table, partition it by key_id, and rank the timestamp, planner tend to range over every row in data table to get `rank=1` data, then join it with key table, finally returns it back to client. so it’s so slow, we current have about 30000 keys in key table, each project has about 2000 keys, and almost 100 milion data rows in data table. It usually takes at least 60 second to get the particular version of data. ","date":"2023-02-12","objectID":"/idx-only-scan/:1:0","tags":null,"title":"Optimize a SELECT query up to 60x faster","uri":"/idx-only-scan/"},{"categories":null,"content":"Improvement: Index-Only Scan But this query still can be better, There’s a new feature introduced in PostgreSQL 9.2, which allow us to get data from index itself, without touching the actual table data. The documentation stats that There are two fundamental restrictions on when this method can be used: The index type must support index-only scans. B-tree indexes always do. GiST and SP-GiST indexes support index-only scans for some operator classes but not others. Other index types have no support. The underlying requirement is that the index must physically store, or else be able to reconstruct, the original data value for each index entry. As a counterexample, GIN indexes cannot support index-only scans because each index entry typically holds only part of the original data value. The query must reference only columns stored in the index. For example, given an index on columns x and y of a table that also has a column z, these queries could use index-only scans: The first one is staicfied because we are using B-tree index. The second one can be satisfied by modifying our SQL query, We can build the mapping between key_id and the rank=1 timestamp first, WITH map AS ( SELECT key_id, timestamp FROM ( SELECT key_id, timestamp, rank() OVER (PARTITION BY key_id ORDER BY TIMESTAMP DESC) AS rank FROM dbData where \"timestamp\" \u003c= 10000 and key_id \u003c 100 ) sub WHERE rank = 1) SELECT * FROM map; Result will be like: key_id | timestamp --------+----------- 1 | 10000 2 | 300 3 | 6000 4 | 90303 and then, get actual data from dbData with specific key_id and timestamp pair. WITH map AS ( SELECT key_id, timestamp FROM ( SELECT key_id, timestamp, rank() OVER (PARTITION BY key_id ORDER BY TIMESTAMP DESC) AS rank FROM dbData where \"timestamp\" \u003c= 10000 and key_id \u003c 100 ) sub WHERE rank = 1) SELECT dbKey.*, dbData.* FROM dbKey INNER JOIN map m ON m.key_id = dbKey.id INNER JOIN dbData ON dbData.key_id = m.key_id AND m.timestamp = dbData.timestamp; The reason we build the map first is that the select list in map are all stored in the index, which satisfied requirement 2 in the documentation, and later when we query dbData , we can still have Index Scan. Here’s the example query plan Reference: PostgreSQL Wiki ","date":"2023-02-12","objectID":"/idx-only-scan/:2:0","tags":null,"title":"Optimize a SELECT query up to 60x faster","uri":"/idx-only-scan/"},{"categories":null,"content":"This is my first glance of ChatGPT, and I ask her to generate a peice of code in Haskell, which can map a function to a list. The result she generated is totally correct, and can be run in playground. addOneToEach :: [Int] -\u003e [Int] addOneToEach xs = map (+1) xs myMap :: (a -\u003e b) -\u003e [a] -\u003e [b] myMap _ [] = [] myMap f (x:xs) = f x : myMap f xs main = do let myList = [1, 2, 3, 4] let doubledList = myMap (*2) myList print doubledList -- Output: [2,4,6,8] Here’s the link to our chat: https://sharegpt.com/c/yedzb1N ","date":"2023-01-21","objectID":"/chatgpt-first-glance/:0:0","tags":null,"title":"ChatGPT First Glance","uri":"/chatgpt-first-glance/"},{"categories":null,"content":"Hello, This is my first time trying Hugo! Inline Formula: SELECT 'hello-world' FROM me Block Formula: ","date":"2023-01-08","objectID":"/my-first-post/:0:0","tags":null,"title":"My First Post","uri":"/my-first-post/"},{"categories":null,"content":"I am unknowntpo, a Backend Software Engineer. ","date":"2023-01-08","objectID":"/about/:0:0","tags":null,"title":"About me","uri":"/about/"}]